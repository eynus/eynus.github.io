<!DOCTYPE html><html lang="zh-CN"><head><meta name="generator" content="Hexo 3.8.0"><meta charset="utf-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1"><meta name="author" content="Eynus."><link rel="alternative" href="/atom.xml" title="I am Eynus." type="application/atom+xml"><link rel="icon" href="/favicon.png"><title>js继承的几种方式 - I am Eynus.</title><link rel="stylesheet" href="/css/main.css"><link rel="stylesheet" href="/js/fancybox/jquery.fancybox.min.css"><!--[if lt IE 9]><script>(function(a,b){a="abbr article aside audio bdi canvas data datalist details dialog figcaption figure footer header hgroup main mark meter nav output progress section summary template time video".split(" ");for(b=a.length-1;b>=0;b--)document.createElement(a[b])})()</script><![endif]--><script src="/js/jquery-3.1.1.min.js"></script><script src="/js/fancybox/jquery.fancybox.min.js"></script></head><body style="opacity:0"><header class="head"><h1 class="head-title u-fl"><a href="/">I am Eynus.</a></h1><nav class="head-nav u-fr"><ul class="head-nav__list"><li class="head-nav__item"><a class="head-nav__link" href="/archives">カタログ/（目录）</a></li></ul></nav></header><main class="main"><article class="post"><header class="post__head"><time class="post__time" datetime="2019-06-27T10:02:04.000Z">June 27, 2019</time><h1 class="post__title"><a href="/2019/06/27/js继承的几种方式/">js继承的几种方式</a></h1><div class="post__main echo"><p>实际上不管代码怎么变，继承都基于两种方式：<br><strong>1.通过原型链，</strong>即子类的原型指向父类的实例从而实现原型共享。<br><strong>2.借用构造函数，</strong>即通过js的apply、call实现子类调用父类的属性、方法；</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Animal</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">　　<span class="keyword">this</span>.species = <span class="string">"动物"</span>;</span><br><span class="line">&#125;</span><br><span class="line">Animal.prototype.getSpecies= <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="keyword">this</span>.species);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//需求：让Cat继承Animal的属性和方法</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Cat</span>(<span class="params">name,age</span>)</span>&#123;</span><br><span class="line">　   <span class="keyword">this</span>.name = name;</span><br><span class="line">　　　<span class="keyword">this</span>.age = age;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="原型链"><a href="#原型链" class="headerlink" title="原型链"></a>原型链</h4><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Cat</span>(<span class="params">name,age</span>)</span>&#123;</span><br><span class="line">　   <span class="keyword">this</span>.name = name;</span><br><span class="line">　　　<span class="keyword">this</span>.age = age;</span><br><span class="line">&#125;</span><br><span class="line">Cat.prototype = <span class="keyword">new</span> Animal();</span><br><span class="line"><span class="keyword">const</span> miao = <span class="keyword">new</span> Cat(<span class="string">"miao"</span>,<span class="number">2</span>)</span><br><span class="line"><span class="comment">//测试</span></span><br><span class="line">miao.getSpecies()<span class="comment">//动物</span></span><br><span class="line">miao.species;	<span class="comment">//动物</span></span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">缺点：</span><br><span class="line">1.属性是引用类型时，多个实例共享同一个该属性。</span><br><span class="line">2.无法向父级构造函数传参</span><br></pre></td></tr></table></figure>
<h4 id="借用构造函数"><a href="#借用构造函数" class="headerlink" title="借用构造函数"></a>借用构造函数</h4><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Cat</span>(<span class="params">name,age</span>)</span>&#123;</span><br><span class="line">    Animal.call(<span class="keyword">this</span>)</span><br><span class="line">　   <span class="keyword">this</span>.name = name;</span><br><span class="line">　　　<span class="keyword">this</span>.age = age;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">const</span> miao = <span class="keyword">new</span> Cat(<span class="string">"miao"</span>,<span class="number">2</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">//测试</span></span><br><span class="line">miao.getSpecies()<span class="comment">//报错</span></span><br><span class="line">miao.species;	<span class="comment">//动物</span></span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">优点</span><br><span class="line">1.引用类型值不会相互影响</span><br><span class="line">2.能向父级构造函数传参</span><br><span class="line">缺点：</span><br><span class="line">1.破坏复用性</span><br><span class="line">如果需要继承方法，必须把方法写到构造函数中，但这样的话每创建一个实例都会创建一遍方法，浪费资源。</span><br></pre></td></tr></table></figure>
<h4 id="组合式继承-原型链-借用构造函数"><a href="#组合式继承-原型链-借用构造函数" class="headerlink" title="组合式继承=原型链+借用构造函数"></a>组合式继承=原型链+借用构造函数</h4><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Cat</span>(<span class="params">name, age</span>) </span>&#123;</span><br><span class="line">        Animal.call(<span class="keyword">this</span>);</span><br><span class="line">        <span class="keyword">this</span>.name = name;</span><br><span class="line">        <span class="keyword">this</span>.age = age;</span><br><span class="line">    &#125;</span><br><span class="line">	Cat.prototype = <span class="keyword">new</span> Animal();</span><br><span class="line">    <span class="keyword">const</span> miao = <span class="keyword">new</span> Cat(<span class="string">"miao"</span>, <span class="number">2</span>)</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">优点：融合2者的优点，取长补短：把共享的属性和方法用原型链继承实现，独享的属性和方法借用构造函数实现。所以组合继承几乎完美实现了js的继承。</span><br><span class="line">缺点：调用两次父级构造函数，导致子类原型对象创建了多余属性</span><br></pre></td></tr></table></figure>
<h4 id="原型式继承"><a href="#原型式继承" class="headerlink" title="原型式继承"></a>原型式继承</h4><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Cat</span>(<span class="params">name,age</span>)</span>&#123;</span><br><span class="line">　   <span class="keyword">this</span>.name = name;</span><br><span class="line">　　　<span class="keyword">this</span>.age = age;</span><br><span class="line">&#125;</span><br><span class="line">Cat.prototype = <span class="built_in">Object</span>.create(Animal.prototype)</span><br><span class="line">Cat.prototype.constructor = Cat;</span><br><span class="line"><span class="keyword">const</span> miao = <span class="keyword">new</span> Cat(<span class="string">"miao"</span>,<span class="number">2</span>)</span><br><span class="line"><span class="comment">//测试</span></span><br><span class="line">miao.getSpecies()<span class="comment">//动物</span></span><br><span class="line">miao.species;<span class="comment">//undefined</span></span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">优点：无需使用构造函数</span><br><span class="line">缺点：和原型链模式一样，存在引用类型的问题</span><br></pre></td></tr></table></figure>
<h4 id="寄生式继承"><a href="#寄生式继承" class="headerlink" title="寄生式继承"></a>寄生式继承</h4><blockquote>
<p>寄生式继承可以理解为是原型式继承的增强。在原型式继承中我们创建了一个新对象，寄生式继承便是在新对象中添加方法，以增强对象。</p>
</blockquote>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//使用场景：在主要考虑对象而不是构造函数和自定义类型时</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">increase</span>(<span class="params">obj</span>)</span>&#123;</span><br><span class="line">    <span class="keyword">var</span> object = <span class="built_in">Object</span>.create(obj);</span><br><span class="line">    object.getProp = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="keyword">this</span>.species)</span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="keyword">return</span> object;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//使用:cat继承animal,并有自己的方法</span></span><br><span class="line">cat = increase(animal)</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">缺陷：破坏了复用性</span><br></pre></td></tr></table></figure>
<h4 id="寄生组合式继承"><a href="#寄生组合式继承" class="headerlink" title="寄生组合式继承"></a>寄生组合式继承</h4><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">	<span class="function"><span class="keyword">function</span> <span class="title">Cat</span>(<span class="params">name, age</span>) </span>&#123;</span><br><span class="line">       Animal.call(<span class="keyword">this</span>);</span><br><span class="line">       <span class="keyword">this</span>.name = name;</span><br><span class="line">       <span class="keyword">this</span>.age = age;</span><br><span class="line">   &#125;</span><br><span class="line">Cat.prototype = <span class="built_in">Object</span>.create(Animal.prototype);</span><br><span class="line">   Cat.prototype.constructor = Cat;</span><br><span class="line">   <span class="keyword">const</span> miao = <span class="keyword">new</span> Cat(<span class="string">"miao"</span>, <span class="number">2</span>)</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">寄生式+组合式，解决了各种问题</span><br></pre></td></tr></table></figure>
<h4 id="ES6继承-是ES5prototype的语法糖"><a href="#ES6继承-是ES5prototype的语法糖" class="headerlink" title="ES6继承(是ES5prototype的语法糖)"></a>ES6继承(是ES5prototype的语法糖)</h4><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Animal</span></span>&#123;</span><br><span class="line">    <span class="keyword">constructor</span>()&#123;</span><br><span class="line">        <span class="keyword">this</span>.species = <span class="string">'动物'</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    getSpecies()&#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="keyword">this</span>.species);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Cat</span></span>&#123;</span><br><span class="line">    <span class="keyword">constructor</span>(name,age)&#123;</span><br><span class="line">        <span class="keyword">super</span>();</span><br><span class="line">        <span class="keyword">this</span>.name = name;</span><br><span class="line">        <span class="keyword">this</span>.age = age;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div></header><footer class="post__foot u-cf"><ul class="post__tag u-fl"><li class="post__tag__item"><a class="post__tag__link" href="/tags/js/">js</a></li></ul></footer></article><section class="reward"><a class="btn-reward" href="#">打赏</a><div class="reward-wrapper clearfix"><img src="/img/wechat.png" title="微信"></div></section><div class="comments" id="v-container"><script src="//cdn1.lncld.net/static/js/3.0.4/av-min.js"></script><script src="//unpkg.com/valine/dist/Valine.min.js"></script><script>new Valine({
  el: '#v-container',
  appId: 'OBALSfJMkMbTcVCkNihDqCEu-gzGzoHsz',
  appKey: 'mdaD2JiJU4lQHSA0nHNRvJOc',
  avatar: 'retro',
  lang: 'zh-cn',
  placeholder: 'balabala~',
  notify: false,
  verify: false,
  pageSize: 20,
  avatarForce: false,
  visitor: true,
  highlight: true
});</script></div></main><footer class="foot"><div class="foot-copy">&copy; 2019 Eynus.</div></footer><script src="/js/scroller.js"></script><script src="/js/main.js"></script></body></html>