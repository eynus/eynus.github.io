<!DOCTYPE html><html lang="zh-CN"><head><meta name="generator" content="Hexo 3.8.0"><meta charset="utf-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1"><meta name="author" content="Eynus."><link rel="alternative" href="/atom.xml" title="I am Eynus." type="application/atom+xml"><link rel="icon" href="/favicon.png"><title>ES6-暂时性死区 - I am Eynus.</title><link rel="stylesheet" href="/css/main.css"><link rel="stylesheet" href="/js/fancybox/jquery.fancybox.min.css"><!--[if lt IE 9]><script>(function(a,b){a="abbr article aside audio bdi canvas data datalist details dialog figcaption figure footer header hgroup main mark meter nav output progress section summary template time video".split(" ");for(b=a.length-1;b>=0;b--)document.createElement(a[b])})()</script><![endif]--><script src="/js/jquery-3.1.1.min.js"></script><script src="/js/fancybox/jquery.fancybox.min.js"></script></head><body style="opacity:0"><header class="head"><h1 class="head-title u-fl"><a href="/">I am Eynus.</a></h1><nav class="head-nav u-fr"><ul class="head-nav__list"><li class="head-nav__item"><a class="head-nav__link" href="/archives">カタログ/（目录）</a></li></ul></nav></header><main class="main"><article class="post"><header class="post__head"><time class="post__time" datetime="2019-05-14T08:09:39.000Z">May 14, 2019</time><h1 class="post__title"><a href="/2019/05/14/ES6-暂时性死区/">ES6-暂时性死区</a></h1><div class="post__main echo"><h3 id="1-let命令的暂时性死区"><a href="#1-let命令的暂时性死区" class="headerlink" title="1.let命令的暂时性死区"></a>1.let命令的暂时性死区</h3><p>块级作用域存在let命令时，它所声明的变量就“绑定”了这个区域。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> a=<span class="number">1</span>;</span><br><span class="line"><span class="keyword">if</span>(<span class="literal">true</span>)&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(a);<span class="comment">//报错。Cannot access 'a' before initialization</span></span><br><span class="line">    <span class="keyword">let</span> a=<span class="number">2</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//分析：</span></span><br><span class="line"><span class="comment">//1.因为有let命令,所以if这个块区域中的a变量只能是局部变量a,(而不是全局变量a=1)</span></span><br><span class="line"><span class="comment">//2.因为let的变量声明不会提前，所以 console.log(a)时a还没有声明,不可获取，此时会报错</span></span><br><span class="line"><span class="comment">//3.代码块中,只要在这个let声明变量前,使用到a都会报错，这个区域就叫做暂时性死区(const同理)</span></span><br></pre></td></tr></table></figure>
<p>暂时性死区(temporal dead zone,简称TDZ)：指的就是代码块内，在let/const命令声明变量之前，都属于这个变量的“死区”。</p>
<h5 id="1-暂时性死区导致typeof不再是一个100-安全的操作"><a href="#1-暂时性死区导致typeof不再是一个100-安全的操作" class="headerlink" title="1.暂时性死区导致typeof不再是一个100%安全的操作"></a>1.暂时性死区导致typeof不再是一个100%安全的操作</h5><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//在没有let之前，运算符typeof100%安全，不会报错</span></span><br><span class="line"><span class="keyword">typeof</span> undeclared_variable;<span class="comment">//undeclared_variable并不存在。此时输出'undefined'</span></span><br></pre></td></tr></table></figure>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//有了let之后，会报错</span></span><br><span class="line"><span class="keyword">typeof</span> x; <span class="comment">//Cannot access 'bcd' before initialization</span></span><br><span class="line"><span class="keyword">let</span> x;</span><br></pre></td></tr></table></figure>
<p>这样的设计是为了让大家养成良好的编程习惯：变量声明之后再使用。</p>
<h5 id="2-其他死区"><a href="#2-其他死区" class="headerlink" title="2.其他死区"></a>2.其他死区</h5><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">bar</span>(<span class="params">x=y,y=<span class="number">1</span></span>)</span>&#123;</span><br><span class="line">    <span class="keyword">return</span> [x,y];</span><br><span class="line">&#125;</span><br><span class="line">bar();<span class="comment">//报错。 Cannot access 'y' before initialization</span></span><br><span class="line"><span class="comment">//分析：参数中x=y时，y还没有声明，属于“死区”</span></span><br></pre></td></tr></table></figure>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> x = x;<span class="comment">//不报错</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> x = x;<span class="comment">//报错 Cannot access 'x' before initialization</span></span><br></pre></td></tr></table></figure>
<h5 id="3-暂时性死区的本质"><a href="#3-暂时性死区的本质" class="headerlink" title="3.暂时性死区的本质"></a>3.暂时性死区的本质</h5><p>只要进入当前作用域，所要使用的变量就已经存在，但是不可获取。只有等到声明变量的那一行代码出现，才可以获取和使用变量。</p>
<h3 id="2-let解决了闭包问题"><a href="#2-let解决了闭包问题" class="headerlink" title="2.let解决了闭包问题"></a>2.let解决了闭包问题</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> a=[];</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">var</span> i = <span class="number">0</span>;i&lt;<span class="number">10</span>;i++)&#123;</span><br><span class="line">    a[i] = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">        <span class="built_in">console</span>.log(i);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//调用a[3]中的方法</span></span><br><span class="line">a[<span class="number">3</span>]();<span class="comment">//输出：10</span></span><br><span class="line"><span class="comment">//分析：</span></span><br><span class="line"><span class="comment">//闭包的原因。</span></span><br><span class="line"><span class="comment">//1.在for循环中的i是全局变量。每一次循环,i的值都会变化。a[i]存的function中的i指的都是同一个全局变量i,而且for循环时，只是将函数赋值，并没有执行函数内的语句。</span></span><br><span class="line"><span class="comment">//2.循环结束之后,全局变量i变为10,因此a数组中的每一个function中的i都是10</span></span><br><span class="line"><span class="comment">//3.因此a[3]()执行后,打印10</span></span><br></pre></td></tr></table></figure>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//var换成let解决了这个闭包问题</span></span><br><span class="line"><span class="keyword">var</span> a=[];</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">let</span> i = <span class="number">0</span>;i&lt;<span class="number">10</span>;i++)&#123;</span><br><span class="line">    a[i] = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">        <span class="built_in">console</span>.log(i);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">a[<span class="number">3</span>]();<span class="comment">//输出：3</span></span><br><span class="line"><span class="comment">//分析：</span></span><br><span class="line"><span class="comment">//由于let针对块级作用域，在每个for循环内部有效。在下一个循环时会生成新的变量i</span></span><br></pre></td></tr></table></figure>
<p>tips:函数内部的变量i和循环变量i不在同一个作用域，他们是独立的</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span>(<span class="keyword">let</span> i = <span class="number">0</span>;i&lt;<span class="number">10</span>;i++)&#123;</span><br><span class="line">   <span class="keyword">let</span> i=<span class="string">'abc'</span>;</span><br><span class="line">   <span class="built_in">console</span>.log(i);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//结果：打印10次abc</span></span><br></pre></td></tr></table></figure>
<h3 id="3-块级作用域与函数声明"><a href="#3-块级作用域与函数声明" class="headerlink" title="3.块级作用域与函数声明"></a>3.块级作用域与函数声明</h3><p>ES5中，函数只能在全局或者函数作用域中声明，不能在块级作用域声明。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//在ES5中是非法的，浏览器不报错是因为兼容旧代码</span></span><br><span class="line"><span class="keyword">if</span>(<span class="literal">true</span>)&#123;</span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">f</span>(<span class="params"></span>)</span>&#123;..&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>ES6引入了块级作用域，明确允许在块级作用域声明函数。声明的函数在块级作用域之外不可用。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span>  <span class="title">f</span>(<span class="params"></span>)</span>&#123; <span class="built_in">console</span>.log(<span class="string">"outside"</span>); &#125;</span><br><span class="line">(<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(<span class="literal">false</span>)&#123;</span><br><span class="line">    	<span class="function"><span class="keyword">function</span> <span class="title">f</span>(<span class="params"></span>)</span>&#123; <span class="built_in">console</span>.log(<span class="string">"inside"</span>); &#125;</span><br><span class="line">	&#125;</span><br><span class="line">    f();</span><br><span class="line">&#125;)()</span><br><span class="line"><span class="comment">//分析</span></span><br><span class="line"><span class="comment">//1.在ES5环境中运行时，第二个f函数声明会提升(到if块作用域上方),最后输出：inside</span></span><br><span class="line"><span class="comment">//2.在ES6环境中运行时,f函数只能在if块作用域中使用，因此理论上输出：outside</span></span><br></pre></td></tr></table></figure>
<p>但是，因为改变了块级作用域内声明函数的处理规则，会影响旧代码(即ES6之前在块作用域内声明函数也是可用的)。为了解决这两种冲突，ES6规定浏览器可以另外有自己的行为。</p>
<ol>
<li>允许在块级作用域内声明函数</li>
<li>函数声明类似于var,即会提升到全局/函数作用域头部</li>
<li>函数声明还会提升到所在块级作用域的头部</li>
</ol>
<p>以上3条针对ES6浏览器。其他浏览器依旧将块级作用域内声明函数当作let处理。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//3.因此，上例代码在ES6环境中运行时，函数声明被当作var,进行了变量提升。相当于</span></span><br><span class="line"><span class="function"><span class="keyword">function</span>  <span class="title">f</span>(<span class="params"></span>)</span>&#123; <span class="built_in">console</span>.log(<span class="string">"outside"</span>); &#125;</span><br><span class="line">(<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="keyword">var</span> f= <span class="literal">undefined</span>;</span><br><span class="line">    <span class="keyword">if</span>(<span class="literal">false</span>)&#123;</span><br><span class="line">    	<span class="function"><span class="keyword">function</span> <span class="title">f</span>(<span class="params"></span>)</span>&#123; <span class="built_in">console</span>.log(<span class="string">"inside"</span>); &#125;</span><br><span class="line">	&#125;</span><br><span class="line">    f();</span><br><span class="line">&#125;)()</span><br><span class="line"><span class="comment">//实际上会输出：Uncaught TypeError: f is not a function</span></span><br></pre></td></tr></table></figure>
<p><strong>注意：</strong></p>
<p><strong>1.在块级作用域中声明函数受运行环境影响太大，所以应该避免。如需要，可以写成函数表达式的形式。</strong></p>
<p><strong>2.“ES6的块级作用域允许声明函数”只在使用大括号才成立，当省略大括号时，是不成立的。</strong></p>
</div></header><footer class="post__foot u-cf"><ul class="post__tag u-fl"><li class="post__tag__item"><a class="post__tag__link" href="/tags/ES6/">ES6</a></li></ul></footer></article><section class="reward"><a class="btn-reward" href="#">打赏</a><div class="reward-wrapper clearfix"><img src="/img/wechat.png" title="微信"></div></section><div class="comments" id="v-container"><script src="//cdn1.lncld.net/static/js/3.0.4/av-min.js"></script><script src="//unpkg.com/valine/dist/Valine.min.js"></script><script>new Valine({
  el: '#v-container',
  appId: 'OBALSfJMkMbTcVCkNihDqCEu-gzGzoHsz',
  appKey: 'mdaD2JiJU4lQHSA0nHNRvJOc',
  avatar: 'retro',
  lang: 'zh-cn',
  placeholder: 'balabala~',
  notify: false,
  verify: false,
  pageSize: 20,
  avatarForce: false,
  visitor: true,
  highlight: true
});</script></div></main><footer class="foot"><div class="foot-copy">&copy; 2019 Eynus.</div></footer><script src="/js/scroller.js"></script><script src="/js/main.js"></script></body></html>